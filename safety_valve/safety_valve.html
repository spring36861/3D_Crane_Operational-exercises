<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D å£“åŠ›å®¹å™¨å®‰å…¨é–¥æ¼”ç¤º</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- React & ReactDOM -->
    <script src="https://unpkg.com/react@18/umd/react.production.min.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js" crossorigin></script>
    <!-- Babel -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <style>
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 24px;
            width: 24px;
            border-radius: 50%;
            background: #3b82f6;
            cursor: pointer;
            margin-top: -8px;
            box-shadow: 0 0 5px rgba(0,0,0,0.3);
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 8px;
            cursor: pointer;
            background: #e2e8f0;
            border-radius: 4px;
        }
        /* éš±è—é è¨­æ²è»¸ï¼Œè®“ 3D é«”é©—æ›´å¥½ */
        .no-scrollbar::-webkit-scrollbar {
            display: none;
        }
        .no-scrollbar {
            -ms-overflow-style: none;
            scrollbar-width: none;
        }
    </style>
</head>
<body class="bg-slate-100 min-h-screen font-sans text-slate-800">
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useMemo, useRef } = React;

        // --- å®‰å…¨é–¥è¨­å®šå¸¸æ•¸ ---
        const MAX_PRESSURE = 120;
        const SET_PRESSURE = 100;     // è¨­å®šå£“åŠ› (èµ·è·³å£“åŠ›)
        const SIMMER_PRESSURE = 95;   // åˆå™´å£“åŠ› (å¾®å•Ÿ)
        const RESEAT_PRESSURE = 85;   // å›åº§å£“åŠ› (åœå™´)

        const App = () => {
            const [pressure, setPressure] = useState(50);
            const [valveState, setValveState] = useState('CLOSED');

            // --- ç‹€æ…‹æ›´æ–°é‚è¼¯ (é²æ»¯æ•ˆæ‡‰ Hysteresis) ---
            useEffect(() => {
                if (valveState === 'CLOSED') {
                    if (pressure >= SET_PRESSURE) setValveState('OPEN');
                    else if (pressure >= SIMMER_PRESSURE) setValveState('SIMMERING');
                } else if (valveState === 'SIMMERING') {
                    if (pressure >= SET_PRESSURE) setValveState('OPEN');
                    else if (pressure < SIMMER_PRESSURE) setValveState('CLOSED');
                } else if (valveState === 'OPEN') {
                    if (pressure <= RESEAT_PRESSURE) setValveState('CLOSED');
                }
            }, [pressure, valveState]);

            // --- Three.js ç›¸é—œåƒè€ƒ ---
            const mountRef = useRef(null);
            const pressureRef = useRef(pressure);
            const valveStateRef = useRef(valveState);
            const sceneObjectsRef = useRef({});

            // åŒæ­¥ React ç‹€æ…‹åˆ° Three.js æ¸²æŸ“è¿´åœˆå¯è®€å–çš„ Ref
            useEffect(() => {
                pressureRef.current = pressure;
                valveStateRef.current = valveState;
            }, [pressure, valveState]);

            // --- Three.js å ´æ™¯åˆå§‹åŒ–èˆ‡æ¸²æŸ“ ---
            useEffect(() => {
                const width = mountRef.current.clientWidth;
                const height = mountRef.current.clientHeight;

                // 1. å ´æ™¯èˆ‡ç›¸æ©Ÿ
                const scene = new THREE.Scene();
                scene.background = new THREE.Color('#1e293b'); // æ”¹ç‚ºæ·±è‰²èƒŒæ™¯ (slate-800) è®“è’¸æ°£æ›´æ˜é¡¯
                
                const camera = new THREE.PerspectiveCamera(40, width / height, 0.1, 1000);
                camera.position.set(0, 5, 30);

                const renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(width, height);
                renderer.shadowMap.enabled = true;
                mountRef.current.appendChild(renderer.domElement);

                const controls = new THREE.OrbitControls(camera, renderer.domElement);
                controls.target.set(0, 3, 0);
                controls.enableDamping = true;
                controls.maxPolarAngle = Math.PI / 2 + 0.2; // é™åˆ¶è¦–è§’ä¸è¦è·‘åˆ°åœ°åº•ä¸‹å¤ªå¤š

                // 2. ç‡ˆå…‰
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.5); // ç¨å¾®èª¿æš—å…¨å±€å…‰ä»¥çªé¡¯å°æ¯”
                scene.add(ambientLight);
                
                const dirLight = new THREE.DirectionalLight(0xffffff, 1.0); // å¢å¼·ä¸»å…‰æºè®“é‡‘å±¬åå…‰æ›´æ¼‚äº®
                dirLight.position.set(10, 20, 15);
                dirLight.castShadow = true;
                scene.add(dirLight);

                const backLight = new THREE.DirectionalLight(0xffffff, 0.3);
                backLight.position.set(-10, 10, -15);
                scene.add(backLight);

                // --- 3. å»ºç«‹ 3D æ¨¡å‹ç‰©ä»¶ ---

                // å…±ç”¨æè³ª
                const metalMat = new THREE.MeshStandardMaterial({ color: 0x94a3b8, metalness: 0.6, roughness: 0.4 });
                const darkMetalMat = new THREE.MeshStandardMaterial({ color: 0x475569, metalness: 0.8, roughness: 0.3 });
                const brassMat = new THREE.MeshStandardMaterial({ color: 0xf59e0b, metalness: 0.8, roughness: 0.2 });
                // ç»ç’ƒé–¥é«”æè³ªï¼Œè®“å…§éƒ¨ä½œå‹•æ¸…æ™°å¯è¦‹
                const glassMat = new THREE.MeshPhysicalMaterial({
                    color: 0xbae6fd, transmission: 0.8, opacity: 1, metalness: 0.1, roughness: 0.1, transparent: true
                });

                // (A) å£“åŠ›å®¹å™¨ (Vessel)
                const vesselMat = new THREE.MeshStandardMaterial({ color: 0x94a3b8 });
                sceneObjectsRef.current.vesselMat = vesselMat; // å„²å­˜èµ·ä¾†ä»¥å‹•æ…‹è®Šè‰²
                const vesselGeo = new THREE.CylinderGeometry(5, 5, 8, 32);
                const vessel = new THREE.Mesh(vesselGeo, vesselMat);
                vessel.position.y = -5;
                scene.add(vessel);

                // æ³•è˜­ç›¤ (Flange)
                const flangeGeo = new THREE.CylinderGeometry(3.5, 3.5, 0.5, 32);
                const flange = new THREE.Mesh(flangeGeo, darkMetalMat);
                flange.position.y = -1;
                scene.add(flange);

                // (B) å™´å˜´ (Nozzle / Seat)
                const nozzleGeo = new THREE.CylinderGeometry(1.2, 1.2, 2, 32);
                const nozzle = new THREE.Mesh(nozzleGeo, darkMetalMat);
                nozzle.position.y = 0; // é ‚éƒ¨åœ¨ y = 1
                scene.add(nozzle);

                // (C) ç»ç’ƒé–¥é«” (Valve Body)
                const bodyGeo = new THREE.CylinderGeometry(3, 3, 4, 32);
                const body = new THREE.Mesh(bodyGeo, glassMat);
                body.position.y = 3;
                scene.add(body);

                // æ’æ”¾å‡ºå£ (Outlet Pipe)
                const outletGeo = new THREE.CylinderGeometry(1.2, 1.2, 4, 32);
                const outlet = new THREE.Mesh(outletGeo, metalMat);
                outlet.rotation.z = Math.PI / 2;
                outlet.position.set(4, 3, 0);
                scene.add(outlet);

                // (D) æ´»å‹•çµ„ä»¶ç¾¤çµ„ (Moving Parts: é–¥ç“£ã€é–¥æ¡¿ã€å½ˆç°§ä¸‹æ‰˜ç›¤)
                const movingParts = new THREE.Group();
                scene.add(movingParts);
                sceneObjectsRef.current.movingParts = movingParts;

                // é–¥ç“£ (Disc) - æ¥è§¸é»åœ¨ y = 1.2 (å‰›å¥½è²¼é½Š Nozzle é ‚éƒ¨)
                const discGeo = new THREE.CylinderGeometry(1.4, 1.4, 0.4, 32);
                const disc = new THREE.Mesh(discGeo, brassMat);
                disc.position.y = 1.2; 
                movingParts.add(disc);

                // é–¥æ¡¿ (Stem)
                const stemGeo = new THREE.CylinderGeometry(0.2, 0.2, 8, 16);
                const stem = new THREE.Mesh(stemGeo, metalMat);
                stem.position.y = 5.4;
                movingParts.add(stem);

                // å½ˆç°§ä¸‹æ‰˜ç›¤ (Bottom Spring Plate)
                const bottomPlateGeo = new THREE.CylinderGeometry(1.5, 1.5, 0.2, 32);
                const bottomPlate = new THREE.Mesh(bottomPlateGeo, darkMetalMat);
                bottomPlate.position.y = 6.5; // å½ˆç°§åº•éƒ¨èµ·å§‹é»
                movingParts.add(bottomPlate);

                // (E) å›ºå®šæ”¯æ¶çµæ§‹ (Yoke)
                // é–¥é«”ä¸Šè“‹
                const topCoverGeo = new THREE.CylinderGeometry(3.2, 3.2, 0.4, 32);
                const topCover = new THREE.Mesh(topCoverGeo, darkMetalMat);
                topCover.position.y = 5.2;
                scene.add(topCover);

                // é›™å´æ”¯æŸ±
                const pillarGeo = new THREE.CylinderGeometry(0.3, 0.3, 5, 16);
                const pillar1 = new THREE.Mesh(pillarGeo, metalMat);
                pillar1.position.set(2.2, 7.7, 0);
                scene.add(pillar1);
                const pillar2 = new THREE.Mesh(pillarGeo, metalMat);
                pillar2.position.set(-2.2, 7.7, 0);
                scene.add(pillar2);

                // é ‚éƒ¨æ©«æ¨‘èˆ‡å½ˆç°§ä¸Šæ‰˜ç›¤
                const topBeamGeo = new THREE.BoxGeometry(5.5, 0.6, 2);
                const topBeam = new THREE.Mesh(topBeamGeo, darkMetalMat);
                topBeam.position.y = 10.2;
                scene.add(topBeam);
                
                const topPlateGeo = new THREE.CylinderGeometry(1.5, 1.5, 0.2, 32);
                const topPlate = new THREE.Mesh(topPlateGeo, darkMetalMat);
                topPlate.position.y = 9.8; // å½ˆç°§é ‚éƒ¨çµ‚é»
                scene.add(topPlate);

                // é ‚éƒ¨èª¿ç¯€èºçµ² (Adjusting Screw)
                const screwGeo = new THREE.CylinderGeometry(0.4, 0.4, 1.5, 16);
                const screw = new THREE.Mesh(screwGeo, brassMat);
                screw.position.y = 11;
                scene.add(screw);

                // (F) å‹•æ…‹å½ˆç°§ (Spring)
                let springMesh = null;
                const updateSpringGeometry = (bottomY, topY) => {
                    if (springMesh) {
                        scene.remove(springMesh);
                        springMesh.geometry.dispose();
                        springMesh.material.dispose();
                    }
                    const points = [];
                    const coils = 5;
                    const segments = 100;
                    for (let i = 0; i <= segments; i++) {
                        const t = i / segments;
                        const angle = t * Math.PI * 2 * coils;
                        const x = Math.cos(angle) * 1.2;
                        const z = Math.sin(angle) * 1.2;
                        const y = bottomY + t * (topY - bottomY);
                        points.push(new THREE.Vector3(x, y, z));
                    }
                    const curve = new THREE.CatmullRomCurve3(points);
                    const tubeGeo = new THREE.TubeGeometry(curve, segments, 0.15, 8, false);
                    const tubeMat = new THREE.MeshStandardMaterial({ color: 0x1e293b, metalness: 0.3, roughness: 0.7 });
                    springMesh = new THREE.Mesh(tubeGeo, tubeMat);
                    scene.add(springMesh);
                };

                // (G) è’¸æ°£ç²’å­ç³»çµ± (Steam Particles)
                const particlesGroup = new THREE.Group();
                scene.add(particlesGroup);
                const particleData = [];

                // --- æ¸²æŸ“èˆ‡å‹•ç•«è¿´åœˆ ---
                let animationId;
                let currentDiscOffset = 0;

                const animate = () => {
                    animationId = requestAnimationFrame(animate);
                    controls.update();

                    const currentPressure = pressureRef.current;
                    const currentState = valveStateRef.current;

                    // 1. è™•ç†å®¹å™¨è®Šè‰² (éš¨å£“åŠ›è®Šç´…)
                    const ratio = currentPressure / MAX_PRESSURE;
                    const r = Math.min(1, 0.4 + ratio * 0.6);
                    const g = Math.max(0, 0.8 - ratio * 0.8);
                    const b = Math.max(0, 1.0 - ratio * 1.0);
                    vesselMat.color.setRGB(r, g, b);

                    // 2. è™•ç†é–¥ç“£(Disc)ä½ç§»å¹³æ»‘éæ¸¡
                    let targetOffset = 0;
                    if (currentState === 'OPEN') targetOffset = 1.5;
                    if (currentState === 'SIMMERING') targetOffset = 0.15;
                    
                    // å¹³æ»‘ç§»å‹• (Lerp)
                    currentDiscOffset += (targetOffset - currentDiscOffset) * 0.2;
                    movingParts.position.y = currentDiscOffset;

                    // 3. å³æ™‚é‡ç¹ªå½ˆç°§ (æ ¹æ“šæ‰˜ç›¤ä½ç½®)
                    const springBottomY = 6.6 + currentDiscOffset;
                    const springTopY = 9.7;
                    updateSpringGeometry(springBottomY, springTopY);

                    // 4. è™•ç†è’¸æ°£ç²’å­ç™¼å°„
                    if (currentState === 'OPEN' || currentState === 'SIMMERING') {
                        const isHeavy = currentState === 'OPEN';
                        // æ¯å¹€ç™¼å°„æ©Ÿç‡
                        if (Math.random() > (isHeavy ? 0.2 : 0.6)) {
                            const pGeo = new THREE.SphereGeometry(isHeavy ? 0.8 : 0.4, 8, 8);
                            const pMat = new THREE.MeshBasicMaterial({
                                color: 0xffffff, transparent: true, opacity: isHeavy ? 0.7 : 0.3
                            });
                            const p = new THREE.Mesh(pGeo, pMat);
                            
                            // å¾æ’æ”¾å£èµ·é»ç™¼å°„
                            p.position.set(5.5, 3 + (Math.random()-0.5)*0.5, (Math.random()-0.5)*0.5);
                            
                            const vx = (isHeavy ? 0.8 : 0.2) + Math.random() * 0.4;
                            const vy = (Math.random() - 0.2) * 0.2;
                            const vz = (Math.random() - 0.5) * 0.2;

                            particlesGroup.add(p);
                            particleData.push({
                                mesh: p, vx, vy, vz,
                                life: 0, maxLife: isHeavy ? 50 : 25
                            });
                        }
                    }

                    // 5. æ›´æ–°ç¾æœ‰ç²’å­ç‹€æ…‹
                    for (let i = particleData.length - 1; i >= 0; i--) {
                        const data = particleData[i];
                        data.life++;
                        data.mesh.position.x += data.vx;
                        data.mesh.position.y += data.vy;
                        data.mesh.position.z += data.vz;
                        
                        // æ¨¡æ“¬è’¸æ°£æ“´æ•£èˆ‡æ¶ˆæ•£
                        data.mesh.scale.multiplyScalar(1.04); 
                        data.mesh.material.opacity *= 0.92; 

                        if (data.life > data.maxLife) {
                            particlesGroup.remove(data.mesh);
                            data.mesh.geometry.dispose();
                            data.mesh.material.dispose();
                            particleData.splice(i, 1);
                        }
                    }

                    renderer.render(scene, camera);
                };

                animate();

                // è¦–çª—å¤§å°æ”¹è®Šè‡ªé©æ‡‰
                const handleResize = () => {
                    const w = mountRef.current.clientWidth;
                    const h = mountRef.current.clientHeight;
                    camera.aspect = w / h;
                    camera.updateProjectionMatrix();
                    renderer.setSize(w, h);
                };
                window.addEventListener('resize', handleResize);

                // Cleanup
                return () => {
                    window.removeEventListener('resize', handleResize);
                    cancelAnimationFrame(animationId);
                    if (mountRef.current && renderer.domElement) {
                        mountRef.current.removeChild(renderer.domElement);
                    }
                };
            }, []);

            return (
                <div class="max-w-7xl mx-auto p-4 md:p-8 flex flex-col lg:flex-row gap-8">
                    
                    {/* å·¦å´ï¼š3D è¦–è¦ºæ¼”ç¤ºå€ */}
                    <div class="flex-1 bg-white rounded-2xl shadow-xl overflow-hidden border border-slate-200 flex flex-col min-h-[500px] lg:min-h-[700px]">
                        <div class="bg-slate-800 text-white py-3 px-6 text-lg font-bold flex justify-between items-center z-10 relative shadow-md">
                            <span>3D å…§éƒ¨ä½œå‹•é€è¦–åœ– (å¯æ»‘é¼ æ‹–æ›³æ—‹è½‰)</span>
                            <span className={`px-3 py-1 rounded-full text-sm font-bold ${
                                valveState === 'OPEN' ? 'bg-red-500 text-white' : 
                                valveState === 'SIMMERING' ? 'bg-yellow-400 text-black' : 'bg-emerald-500 text-white'
                            }`}>
                                {valveState === 'OPEN' ? 'å…¨é–‹æ’æ”¾ä¸­' : 
                                 valveState === 'SIMMERING' ? 'åˆå™´å¾®å•Ÿ' : 'å®Œå…¨é—œé–‰'}
                            </span>
                        </div>
                        {/* 3D Canvas æ›è¼‰é» */}
                        <div ref={mountRef} class="flex-1 w-full bg-slate-800 cursor-move relative overflow-hidden">
                            {/* è¦†è“‹ä¸€å±¤æ–‡å­—æç¤º */}
                            <div class="absolute bottom-4 left-4 bg-slate-900/70 backdrop-blur-sm px-3 py-2 rounded-lg text-xs text-slate-300 font-bold pointer-events-none border border-slate-700">
                                ğŸ’¡ æç¤ºï¼šå·¦éµæ‹–æ›³æ—‹è½‰ / æ»¾è¼ªç¸®æ”¾
                            </div>
                        </div>
                    </div>

                    {/* å³å´ï¼šæ§åˆ¶é¢æ¿èˆ‡è§£èªª */}
                    <div class="w-full lg:w-[400px] flex flex-col gap-6 shrink-0">
                        
                        {/* å„€è¡¨æ¿å¡ç‰‡ */}
                        <div class="bg-white p-6 rounded-2xl shadow-lg border border-slate-200">
                            <h2 class="text-2xl font-bold text-slate-800 mb-6 border-b pb-2 flex items-center gap-2">
                                âš™ï¸ ç³»çµ±å£“åŠ›æ§åˆ¶
                            </h2>
                            
                            <div class="mb-8">
                                <div class="flex justify-between items-end mb-2">
                                    <label class="text-slate-600 font-semibold text-lg">å…§éƒ¨å£“åŠ› (PSI)</label>
                                    <div class={`text-4xl font-black font-mono transition-colors ${
                                        pressure >= SET_PRESSURE ? 'text-red-600' : 
                                        pressure >= SIMMER_PRESSURE ? 'text-orange-500' : 'text-blue-600'
                                    }`}>
                                        {pressure.toFixed(1)}
                                    </div>
                                </div>
                                <input 
                                    type="range" 
                                    min="0" 
                                    max={MAX_PRESSURE} 
                                    step="0.5" 
                                    value={pressure}
                                    onChange={(e) => setPressure(parseFloat(e.target.value))}
                                    class="w-full h-4 bg-slate-200 rounded-lg appearance-none cursor-pointer"
                                />
                                <div class="flex justify-between text-xs text-slate-400 mt-2 font-mono">
                                    <span>0</span>
                                    <span>{RESEAT_PRESSURE} (å›åº§)</span>
                                    <span>{SET_PRESSURE} (èµ·è·³)</span>
                                    <span>{MAX_PRESSURE}</span>
                                </div>
                            </div>

                            <div class="bg-slate-50 rounded-xl p-4 border border-slate-200">
                                <h3 class="font-bold text-slate-700 mb-3">ç•¶å‰å®‰å…¨é–¥ç‹€æ…‹</h3>
                                
                                {valveState === 'CLOSED' && (
                                    <div class="flex items-start gap-3 text-emerald-700 bg-emerald-50 p-3 rounded-lg border border-emerald-200">
                                        <div class="mt-1 text-2xl">ğŸŸ¢</div>
                                        <div>
                                            <div class="font-bold text-lg">é—œé–‰ (Closed)</div>
                                            <p class="text-sm mt-1">å£“åŠ›æ­£å¸¸ã€‚é ‚éƒ¨å½ˆç°§çš„ä¸‹å£“åŠ›é‡å¤§æ–¼å®¹å™¨å…§éƒ¨å£“åŠ›ï¼ŒéŠ…è‰²é–¥ç“£ç·Šå£“åœ¨åº•åº§ä¸Šã€‚</p>
                                        </div>
                                    </div>
                                )}

                                {valveState === 'SIMMERING' && (
                                    <div class="flex items-start gap-3 text-orange-700 bg-orange-50 p-3 rounded-lg border border-orange-200">
                                        <div class="mt-1 text-2xl">ğŸŸ¡</div>
                                        <div>
                                            <div class="font-bold text-lg">åˆå™´ / å¾®å•Ÿ (Simmering)</div>
                                            <p class="text-sm mt-1">å£“åŠ›æ¥è¿‘è¨­å®šå€¼ã€‚å‘ä¸Šæ¨åŠ›å¹¾ä¹æŠµéŠ·å½ˆç°§åŠ›ï¼Œé–¥ç“£å¾®å¹…æŠ¬èµ·ï¼Œå°é‡è’¸æ°£å¾å³å´æ’æ°£ç®¡æ´©å‡ºã€‚</p>
                                        </div>
                                    </div>
                                )}

                                {valveState === 'OPEN' && (
                                    <div class="flex items-start gap-3 text-red-700 bg-red-50 p-3 rounded-lg border border-red-200">
                                        <div class="mt-1 text-2xl animate-pulse">ğŸ”´</div>
                                        <div>
                                            <div class="font-bold text-lg">æ’æ”¾ / èµ·è·³ (Popping)</div>
                                            <p class="text-sm mt-1">å£“åŠ›è¶…æ¨™ï¼é–¥é–€ç¬é–“å…¨é–‹ï¼Œå¤§é‡è’¸æ°£é«˜é€Ÿæ’å‡ºã€‚<b>é ˆç­‰å£“åŠ›é™è‡³ {RESEAT_PRESSURE} PSI ä»¥ä¸‹æ‰æœƒé‡æ–°é—œé–‰ã€‚</b></p>
                                        </div>
                                    </div>
                                )}
                            </div>
                        </div>

                        {/* æ•™å­¸èªªæ˜å¡ç‰‡ */}
                        <div class="bg-white p-6 rounded-2xl shadow-lg border border-slate-200 flex-1 overflow-y-auto no-scrollbar">
                            <h2 class="text-xl font-bold text-slate-800 mb-4 border-b pb-2">ğŸ“– 3D çµ„ä»¶èªªæ˜èˆ‡é²æ»¯æ•ˆæ‡‰</h2>
                            <ul class="space-y-4 text-slate-600 text-sm leading-relaxed">
                                <li class="flex gap-2">
                                    <span class="font-bold min-w-max text-slate-800">é€è¦–ç»ç’ƒé–¥é«”ï¼š</span>
                                    <span>è—è‰²åŠé€æ˜çš„å¤–æ®¼è¨­è¨ˆè®“æ‚¨èƒ½æ¸…æ™°è§€å¯Ÿå…§éƒ¨<b>éŠ…è‰²é–¥ç“£ (Disc)</b> é›¢é–‹ <b>é–¥åº§ (Seat)</b> çš„éç¨‹ã€‚</span>
                                </li>
                                <li class="flex gap-2">
                                    <span class="font-bold min-w-max text-slate-800">å‹•æ…‹å½ˆç°§ï¼š</span>
                                    <span>ä½æ–¼é ‚éƒ¨æ”¯æ¶å…§ï¼Œç•¶èµ·è·³ç™¼ç”Ÿæ™‚ï¼Œæ‚¨å¯ä»¥è§€å¯Ÿåˆ°å½ˆç°§è¢«ä¸‹æ–¹å‚³ä¾†çš„å·¨å¤§åŠ›é‡ç¬é–“å£“ç¸®ã€‚</span>
                                </li>
                                <li class="flex gap-2">
                                    <span class="font-bold min-w-max text-slate-800 text-blue-600">å•Ÿé–‰å£“å·® (Blowdown)ï¼š</span>
                                    <span>è«‹å˜—è©¦å°‡å£“åŠ›æ¨è‡³ 100 PSI è§¸ç™¼å…¨é–‹ï¼Œå†å¾€å›æ‹‰åˆ° 90 PSIã€‚æ‚¨æœƒç™¼ç¾é–¥é–€ä¾ç„¶ä¿æŒé–‹å•Ÿç‹€æ…‹ï¼é€™æ˜¯å› ç‚ºæµé«”åŠ›å­¸ä¸­çš„ã€Œåè¡ç›¤ä½œç”¨ã€ï¼Œå¿…é ˆé™åˆ° 85 PSI æ‰èƒ½è®“å½ˆç°§é‡æ–°å…‹æœæ°£é«”æ¨åŠ›ä½¿é–¥é–€å›åº§ã€‚</span>
                                </li>
                            </ul>
                        </div>

                    </div>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>

<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D å£“åŠ›å®¹å™¨å®‰å…¨é–¥æ¼”ç¤º</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- React & ReactDOM -->
    <script src="https://unpkg.com/react@18/umd/react.production.min.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js" crossorigin></script>
    <!-- Babel -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <style>
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 28px;
            width: 28px;
            border-radius: 50%;
            background: #3b82f6;
            cursor: pointer;
            margin-top: -11px;
            box-shadow: 0 0 10px rgba(0,0,0,0.5), inset 0 0 4px rgba(255,255,255,0.4);
            position: relative;
            z-index: 10;
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 6px;
            cursor: pointer;
            background: #475569;
            border-radius: 3px;
        }
        .no-scrollbar::-webkit-scrollbar {
            display: none;
        }
        .no-scrollbar {
            -ms-overflow-style: none;
            scrollbar-width: none;
        }
    </style>
</head>
<body class="bg-slate-900 min-h-screen font-sans text-slate-800 flex items-center justify-center p-0 md:p-4">
    <div id="root" class="w-full max-w-7xl h-[100dvh] md:h-[90vh] md:min-h-[600px]"></div>

    <script type="text/babel">
        const { useState, useEffect, useMemo, useRef } = React;

        // --- å®‰å…¨é–¥è¨­å®šå¸¸æ•¸ ---
        const MAX_PRESSURE = 120;
        const SET_PRESSURE = 100;     // è¨­å®šå£“åŠ› (èµ·è·³å£“åŠ›)
        const SIMMER_PRESSURE = 95;   // åˆå™´å£“åŠ› (å¾®å•Ÿ)
        const RESEAT_PRESSURE = 85;   // å›åº§å£“åŠ› (åœå™´)

        const App = () => {
            const [pressure, setPressure] = useState(50);
            const [valveState, setValveState] = useState('CLOSED');

            // --- ç‹€æ…‹æ›´æ–°é‚è¼¯ (é²æ»¯æ•ˆæ‡‰ Hysteresis) ---
            useEffect(() => {
                if (valveState === 'CLOSED') {
                    if (pressure >= SET_PRESSURE) setValveState('OPEN');
                    else if (pressure >= SIMMER_PRESSURE) setValveState('SIMMERING');
                } else if (valveState === 'SIMMERING') {
                    if (pressure >= SET_PRESSURE) setValveState('OPEN');
                    else if (pressure < SIMMER_PRESSURE) setValveState('CLOSED');
                } else if (valveState === 'OPEN') {
                    if (pressure <= RESEAT_PRESSURE) setValveState('CLOSED');
                }
            }, [pressure, valveState]);

            // --- Three.js ç›¸é—œåƒè€ƒ ---
            const mountRef = useRef(null);
            const pressureRef = useRef(pressure);
            const valveStateRef = useRef(valveState);
            const sceneObjectsRef = useRef({});

            useEffect(() => {
                pressureRef.current = pressure;
                valveStateRef.current = valveState;
            }, [pressure, valveState]);

            // --- Three.js å ´æ™¯åˆå§‹åŒ–èˆ‡æ¸²æŸ“ ---
            useEffect(() => {
                if (!mountRef.current) return;

                const initialWidth = mountRef.current.clientWidth || window.innerWidth;
                const initialHeight = mountRef.current.clientHeight || window.innerHeight;

                const scene = new THREE.Scene();
                scene.background = new THREE.Color('#0f172a'); // æ·±è‰²èƒŒæ™¯è‰²
                
                // ã€æ ¸å¿ƒèª¿æ•´ã€‘é›»è…¦ç‰ˆå°‡ç›¸æ©Ÿç›®æ¨™å³ç§»ï¼Œè®“æ¨¡å‹åœ¨ç•«é¢ä¸Šé å·¦ï¼Œé¿é–‹å³å´é¢æ¿
                const isMobileInit = initialWidth < 768;
                const cameraOffsetX = isMobileInit ? 0 : 5.5;

                const camera = new THREE.PerspectiveCamera(40, initialWidth / initialHeight, 0.1, 1000);
                camera.position.set(cameraOffsetX, 5, 35); 

                const renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(initialWidth, initialHeight);
                renderer.shadowMap.enabled = true;
                mountRef.current.appendChild(renderer.domElement);

                const controls = new THREE.OrbitControls(camera, renderer.domElement);
                controls.target.set(cameraOffsetX, 3, 0); 
                controls.enableDamping = true;
                controls.maxPolarAngle = Math.PI / 2 + 0.2; 

                // ç‡ˆå…‰
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.5); 
                scene.add(ambientLight);
                
                const dirLight = new THREE.DirectionalLight(0xffffff, 1.0); 
                dirLight.position.set(10, 20, 15);
                dirLight.castShadow = true;
                scene.add(dirLight);

                const backLight = new THREE.DirectionalLight(0xffffff, 0.3);
                backLight.position.set(-10, 10, -15);
                scene.add(backLight);

                // --- å»ºç«‹ 3D æ¨¡å‹ç‰©ä»¶ ---
                const metalMat = new THREE.MeshStandardMaterial({ color: 0x94a3b8, metalness: 0.6, roughness: 0.4 });
                const darkMetalMat = new THREE.MeshStandardMaterial({ color: 0x475569, metalness: 0.8, roughness: 0.3 });
                const brassMat = new THREE.MeshStandardMaterial({ color: 0xf59e0b, metalness: 0.8, roughness: 0.2 });
                const glassMat = new THREE.MeshPhysicalMaterial({
                    color: 0xbae6fd, transmission: 0.8, opacity: 1, metalness: 0.1, roughness: 0.1, transparent: true
                });

                // (A) å£“åŠ›å®¹å™¨ (Vessel)
                const vesselMat = new THREE.MeshStandardMaterial({ color: 0x94a3b8 });
                sceneObjectsRef.current.vesselMat = vesselMat; 
                const vesselGeo = new THREE.CylinderGeometry(5, 5, 8, 32);
                const vessel = new THREE.Mesh(vesselGeo, vesselMat);
                vessel.position.y = -5;
                scene.add(vessel);

                const flangeGeo = new THREE.CylinderGeometry(3.5, 3.5, 0.5, 32);
                const flange = new THREE.Mesh(flangeGeo, darkMetalMat);
                flange.position.y = -1;
                scene.add(flange);

                // (B) å™´å˜´ (Nozzle / Seat)
                const nozzleGeo = new THREE.CylinderGeometry(1.2, 1.2, 2, 32);
                const nozzle = new THREE.Mesh(nozzleGeo, darkMetalMat);
                nozzle.position.y = 0; 
                scene.add(nozzle);

                // (C) ç»ç’ƒé–¥é«” (Valve Body)
                const bodyGeo = new THREE.CylinderGeometry(3, 3, 4, 32);
                const body = new THREE.Mesh(bodyGeo, glassMat);
                body.position.y = 3;
                scene.add(body);

                const outletGeo = new THREE.CylinderGeometry(1.2, 1.2, 4, 32);
                const outlet = new THREE.Mesh(outletGeo, metalMat);
                outlet.rotation.z = Math.PI / 2;
                outlet.position.set(4, 3, 0);
                scene.add(outlet);

                // (D) æ´»å‹•çµ„ä»¶ç¾¤çµ„
                const movingParts = new THREE.Group();
                scene.add(movingParts);
                sceneObjectsRef.current.movingParts = movingParts;

                const discGeo = new THREE.CylinderGeometry(1.4, 1.4, 0.4, 32);
                const disc = new THREE.Mesh(discGeo, brassMat);
                disc.position.y = 1.2; 
                movingParts.add(disc);

                const stemGeo = new THREE.CylinderGeometry(0.2, 0.2, 8, 16);
                const stem = new THREE.Mesh(stemGeo, metalMat);
                stem.position.y = 5.4;
                movingParts.add(stem);

                const bottomPlateGeo = new THREE.CylinderGeometry(1.5, 1.5, 0.2, 32);
                const bottomPlate = new THREE.Mesh(bottomPlateGeo, darkMetalMat);
                bottomPlate.position.y = 6.5; 
                movingParts.add(bottomPlate);

                // (E) å›ºå®šæ”¯æ¶çµæ§‹ (Yoke)
                const topCoverGeo = new THREE.CylinderGeometry(3.2, 3.2, 0.4, 32);
                const topCover = new THREE.Mesh(topCoverGeo, darkMetalMat);
                topCover.position.y = 5.2;
                scene.add(topCover);

                const pillarGeo = new THREE.CylinderGeometry(0.3, 0.3, 5, 16);
                const pillar1 = new THREE.Mesh(pillarGeo, metalMat);
                pillar1.position.set(2.2, 7.7, 0);
                scene.add(pillar1);
                const pillar2 = new THREE.Mesh(pillarGeo, metalMat);
                pillar2.position.set(-2.2, 7.7, 0);
                scene.add(pillar2);

                const topBeamGeo = new THREE.BoxGeometry(5.5, 0.6, 2);
                const topBeam = new THREE.Mesh(topBeamGeo, darkMetalMat);
                topBeam.position.y = 10.2;
                scene.add(topBeam);
                
                const topPlateGeo = new THREE.CylinderGeometry(1.5, 1.5, 0.2, 32);
                const topPlate = new THREE.Mesh(topPlateGeo, darkMetalMat);
                topPlate.position.y = 9.8; 
                scene.add(topPlate);

                const screwGeo = new THREE.CylinderGeometry(0.4, 0.4, 1.5, 16);
                const screw = new THREE.Mesh(screwGeo, brassMat);
                screw.position.y = 11;
                scene.add(screw);

                // (F) å‹•æ…‹å½ˆç°§ (Spring)
                let springMesh = null;
                const updateSpringGeometry = (bottomY, topY) => {
                    if (springMesh) {
                        scene.remove(springMesh);
                        springMesh.geometry.dispose();
                        springMesh.material.dispose();
                    }
                    const points = [];
                    const coils = 5;
                    const segments = 100;
                    for (let i = 0; i <= segments; i++) {
                        const t = i / segments;
                        const angle = t * Math.PI * 2 * coils;
                        const x = Math.cos(angle) * 1.2;
                        const z = Math.sin(angle) * 1.2;
                        const y = bottomY + t * (topY - bottomY);
                        points.push(new THREE.Vector3(x, y, z));
                    }
                    const curve = new THREE.CatmullRomCurve3(points);
                    const tubeGeo = new THREE.TubeGeometry(curve, segments, 0.15, 8, false);
                    const tubeMat = new THREE.MeshStandardMaterial({ color: 0x1e293b, metalness: 0.3, roughness: 0.7 });
                    springMesh = new THREE.Mesh(tubeGeo, tubeMat);
                    scene.add(springMesh);
                };

                // (G) è’¸æ°£ç²’å­ç³»çµ±
                const particlesGroup = new THREE.Group();
                scene.add(particlesGroup);
                const particleData = [];

                // --- æ¸²æŸ“èˆ‡å‹•ç•«è¿´åœˆ ---
                let animationId;
                let currentDiscOffset = 0;

                const animate = () => {
                    animationId = requestAnimationFrame(animate);
                    controls.update();

                    const currentPressure = pressureRef.current;
                    const currentState = valveStateRef.current;

                    const ratio = currentPressure / MAX_PRESSURE;
                    const r = Math.min(1, 0.4 + ratio * 0.6);
                    const g = Math.max(0, 0.8 - ratio * 0.8);
                    const b = Math.max(0, 1.0 - ratio * 1.0);
                    vesselMat.color.setRGB(r, g, b);

                    let targetOffset = 0;
                    if (currentState === 'OPEN') targetOffset = 1.5;
                    if (currentState === 'SIMMERING') targetOffset = 0.15;
                    
                    currentDiscOffset += (targetOffset - currentDiscOffset) * 0.2;
                    movingParts.position.y = currentDiscOffset;

                    const springBottomY = 6.6 + currentDiscOffset;
                    const springTopY = 9.7;
                    updateSpringGeometry(springBottomY, springTopY);

                    if (currentState === 'OPEN' || currentState === 'SIMMERING') {
                        const isHeavy = currentState === 'OPEN';
                        if (Math.random() > (isHeavy ? 0.2 : 0.6)) {
                            const pGeo = new THREE.SphereGeometry(isHeavy ? 0.8 : 0.4, 8, 8);
                            const pMat = new THREE.MeshBasicMaterial({
                                color: 0xffffff, transparent: true, opacity: isHeavy ? 0.7 : 0.3
                            });
                            const p = new THREE.Mesh(pGeo, pMat);
                            
                            p.position.set(5.5, 3 + (Math.random()-0.5)*0.5, (Math.random()-0.5)*0.5);
                            
                            const vx = (isHeavy ? 0.8 : 0.2) + Math.random() * 0.4;
                            const vy = (Math.random() - 0.2) * 0.2;
                            const vz = (Math.random() - 0.5) * 0.2;

                            particlesGroup.add(p);
                            particleData.push({
                                mesh: p, vx, vy, vz,
                                life: 0, maxLife: isHeavy ? 50 : 25
                            });
                        }
                    }

                    for (let i = particleData.length - 1; i >= 0; i--) {
                        const data = particleData[i];
                        data.life++;
                        data.mesh.position.x += data.vx;
                        data.mesh.position.y += data.vy;
                        data.mesh.position.z += data.vz;
                        
                        data.mesh.scale.multiplyScalar(1.04); 
                        data.mesh.material.opacity *= 0.92; 

                        if (data.life > data.maxLife) {
                            particlesGroup.remove(data.mesh);
                            data.mesh.geometry.dispose();
                            data.mesh.material.dispose();
                            particleData.splice(i, 1);
                        }
                    }

                    renderer.render(scene, camera);
                };

                animate();

                // éŸ¿æ‡‰å¼èª¿æ•´
                const handleResize = () => {
                    if (!mountRef.current) return;
                    const w = mountRef.current.clientWidth;
                    const h = mountRef.current.clientHeight;
                    
                    if (w === 0 || h === 0) return;
                    
                    const isMobile = w < 768;
                    const targetOffsetX = isMobile ? 0 : 5.5; // å‹•æ…‹èª¿æ•´æ”å½±æ©Ÿç„¦é»
                    if (controls.target.x !== targetOffsetX) {
                        const deltaX = targetOffsetX - controls.target.x;
                        controls.target.x = targetOffsetX;
                        camera.position.x += deltaX;
                    }

                    camera.aspect = w / h;
                    camera.updateProjectionMatrix();
                    renderer.setSize(w, h);
                };

                const resizeObserver = new ResizeObserver(() => {
                    handleResize();
                });
                if (mountRef.current) resizeObserver.observe(mountRef.current);

                return () => {
                    resizeObserver.disconnect();
                    cancelAnimationFrame(animationId);
                    if (mountRef.current && renderer.domElement) {
                        mountRef.current.removeChild(renderer.domElement);
                    }
                };
            }, []);

            return (
                <div className="relative w-full h-full md:rounded-2xl shadow-2xl overflow-hidden border-0 md:border border-slate-700 bg-slate-900 flex flex-col">
                    
                    {/* é ‚éƒ¨è³‡è¨Šåˆ— */}
                    <div className="absolute top-0 left-0 right-0 z-20 bg-slate-900/60 backdrop-blur-md text-white py-3 px-4 md:px-6 flex justify-between items-center border-b border-slate-700/50">
                        <span className="font-bold text-sm md:text-lg truncate">3D å…§éƒ¨ä½œå‹•é€è¦–åœ–</span>
                        {/* æ‰‹æ©Ÿç‰ˆç¸®å°å·¦ä¸Šè§’æç¤º */}
                        <div className="text-[10px] md:text-xs text-slate-400">ğŸ’¡ å¯æ‹–æ›³æ—‹è½‰ / æ»¾è¼ªç¸®æ”¾</div>
                    </div>

                    {/* 3D Canvas èƒŒæ™¯ */}
                    <div ref={mountRef} className="absolute inset-0 z-0 cursor-move"></div>

                    {/* --- ã€å³ä¸Šè§’ï¼šé–¥é–€ç‹€æ…‹èªªæ˜é¢æ¿ã€‘ --- */}
                    <div className="absolute top-16 right-4 md:top-20 md:right-8 z-10 w-[240px] md:w-[320px]">
                        <div className="bg-slate-800/85 backdrop-blur-xl p-3 md:p-4 rounded-xl shadow-2xl border border-slate-600/50">
                            <h3 className="text-slate-400 text-xs md:text-sm font-bold mb-3 border-b border-slate-600/50 pb-1">é–¥é–€ç‹€æ…‹</h3>
                            
                            {valveState === 'CLOSED' && (
                                <div className="flex items-center gap-3">
                                    <div className="w-4 h-4 rounded-full bg-emerald-400 shadow-[0_0_10px_rgba(52,211,153,0.8)] shrink-0"></div>
                                    <div>
                                        <div className="font-bold text-emerald-400 text-sm md:text-base">é—œé–‰ (Closed)</div>
                                        <p className="text-[10px] md:text-xs mt-1 text-emerald-100/70 leading-relaxed">å£“åŠ›æ­£å¸¸ã€‚å½ˆç°§ä¸‹å£“åŠ›å¤§æ–¼å…§éƒ¨å£“åŠ›ï¼Œé–¥é–€ç·Šé–‰ã€‚</p>
                                    </div>
                                </div>
                            )}

                            {valveState === 'SIMMERING' && (
                                <div className="flex items-center gap-3">
                                    <div className="w-4 h-4 rounded-full bg-orange-400 shadow-[0_0_10px_rgba(251,146,60,0.8)] shrink-0"></div>
                                    <div>
                                        <div className="font-bold text-orange-400 text-sm md:text-base">åˆå™´ / å¾®å•Ÿ</div>
                                        <p className="text-[10px] md:text-xs mt-1 text-orange-100/70 leading-relaxed">æ¥è¿‘è¨­å®šå£“åŠ›ã€‚é–¥ç“£å¾®å¹…æŠ¬èµ·ï¼Œå°é‡è’¸æ°£æ´©æ¼ã€‚</p>
                                    </div>
                                </div>
                            )}

                            {valveState === 'OPEN' && (
                                <div className="flex items-center gap-3">
                                    <div className="w-4 h-4 rounded-full bg-red-500 shadow-[0_0_15px_rgba(239,68,68,1)] animate-pulse shrink-0"></div>
                                    <div>
                                        <div className="font-bold text-red-500 text-sm md:text-base">æ’æ”¾ / èµ·è·³</div>
                                        <p className="text-[10px] md:text-xs mt-1 text-red-100/80 leading-relaxed">å£“åŠ›è¶…æ¨™ï¼é ˆé™è‡³ {RESEAT_PRESSURE} PSI ä»¥ä¸‹æ‰æœƒå›åº§ã€‚</p>
                                    </div>
                                </div>
                            )}
                        </div>
                    </div>

                    {/* --- ã€å³ä¸‹è§’ï¼šç³»çµ±å£“åŠ›æ§åˆ¶é¢æ¿ã€‘ --- */}
                    <div className="absolute bottom-6 left-4 right-4 md:bottom-10 md:right-8 md:left-auto md:w-[360px] z-10">
                        <div className="bg-slate-800/85 backdrop-blur-xl p-5 md:p-6 rounded-2xl shadow-2xl border border-slate-600/50">
                            
                            <div className="flex justify-between items-end mb-6">
                                <label className="text-slate-300 font-bold text-sm md:text-base flex items-center gap-2">
                                    âš™ï¸ ç³»çµ±å£“åŠ›æ§åˆ¶
                                </label>
                                <div className={`text-4xl font-black font-mono tracking-tight transition-colors ${
                                    pressure >= SET_PRESSURE ? 'text-red-400' : 
                                    pressure >= SIMMER_PRESSURE ? 'text-orange-400' : 'text-blue-400'
                                }`}>
                                    {pressure.toFixed(1)}
                                </div>
                            </div>
                            
                            <div className="relative pt-2 pb-6">
                                <input 
                                    type="range" 
                                    min="0" 
                                    max={MAX_PRESSURE} 
                                    step="0.5" 
                                    value={pressure}
                                    onChange={(e) => setPressure(parseFloat(e.target.value))}
                                    className="w-full appearance-none bg-transparent cursor-pointer"
                                />
                                
                                {/* åˆ»åº¦æ¨™ç±¤ */}
                                <div className="absolute w-full mt-3 text-[10px] md:text-xs text-slate-400 font-mono">
                                    <span className="absolute left-0">0</span>
                                    
                                    <div className="absolute flex flex-col items-center" 
                                         style={{ left: `${(RESEAT_PRESSURE / MAX_PRESSURE) * 100}%`, transform: 'translateX(-50%)' }}>
                                        <div className="w-px h-2 bg-slate-400 mb-1"></div>
                                        <span>{RESEAT_PRESSURE}</span>
                                        <span className="text-[9px] text-slate-500 -mt-0.5">(å›åº§)</span>
                                    </div>
                                    
                                    <div className="absolute flex flex-col items-center" 
                                         style={{ left: `${(SET_PRESSURE / MAX_PRESSURE) * 100}%`, transform: 'translateX(-50%)' }}>
                                        <div className="w-px h-2 bg-red-400 mb-1"></div>
                                        <span className="text-red-400 font-bold">{SET_PRESSURE}</span>
                                        <span className="text-[9px] text-red-500/80 -mt-0.5">(èµ·è·³)</span>
                                    </div>
                                    
                                    <span className="absolute right-0">{MAX_PRESSURE}</span>
                                </div>
                            </div>

                        </div>
                    </div>

                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>

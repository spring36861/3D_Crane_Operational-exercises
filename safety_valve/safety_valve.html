<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D å£“åŠ›å®¹å™¨å®‰å…¨é–¥æ¼”ç¤º</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- React & ReactDOM -->
    <script src="https://unpkg.com/react@18/umd/react.production.min.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js" crossorigin></script>
    <!-- Babel -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <style>
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 24px;
            width: 24px;
            border-radius: 50%;
            background: #3b82f6;
            cursor: pointer;
            margin-top: -8px;
            box-shadow: 0 0 5px rgba(0,0,0,0.3);
            position: relative;
            z-index: 10;
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 8px;
            cursor: pointer;
            background: #cbd5e1;
            border-radius: 4px;
        }
        /* éš±è—é è¨­æ²è»¸ï¼Œè®“ 3D é«”é©—æ›´å¥½ */
        .no-scrollbar::-webkit-scrollbar {
            display: none;
        }
        .no-scrollbar {
            -ms-overflow-style: none;
            scrollbar-width: none;
        }
    </style>
</head>
<body class="bg-slate-900 min-h-screen font-sans text-slate-800 flex items-center justify-center p-4">
    <div id="root" class="w-full max-w-7xl h-[90vh] min-h-[600px]"></div>

    <script type="text/babel">
        const { useState, useEffect, useMemo, useRef } = React;

        // --- å®‰å…¨é–¥è¨­å®šå¸¸æ•¸ ---
        const MAX_PRESSURE = 120;
        const SET_PRESSURE = 100;     // è¨­å®šå£“åŠ› (èµ·è·³å£“åŠ›)
        const SIMMER_PRESSURE = 95;   // åˆå™´å£“åŠ› (å¾®å•Ÿ)
        const RESEAT_PRESSURE = 85;   // å›åº§å£“åŠ› (åœå™´)

        const App = () => {
            const [pressure, setPressure] = useState(50);
            const [valveState, setValveState] = useState('CLOSED');

            // --- ç‹€æ…‹æ›´æ–°é‚è¼¯ (é²æ»¯æ•ˆæ‡‰ Hysteresis) ---
            useEffect(() => {
                if (valveState === 'CLOSED') {
                    if (pressure >= SET_PRESSURE) setValveState('OPEN');
                    else if (pressure >= SIMMER_PRESSURE) setValveState('SIMMERING');
                } else if (valveState === 'SIMMERING') {
                    if (pressure >= SET_PRESSURE) setValveState('OPEN');
                    else if (pressure < SIMMER_PRESSURE) setValveState('CLOSED');
                } else if (valveState === 'OPEN') {
                    if (pressure <= RESEAT_PRESSURE) setValveState('CLOSED');
                }
            }, [pressure, valveState]);

            // --- Three.js ç›¸é—œåƒè€ƒ ---
            const mountRef = useRef(null);
            const pressureRef = useRef(pressure);
            const valveStateRef = useRef(valveState);
            const sceneObjectsRef = useRef({});

            // åŒæ­¥ React ç‹€æ…‹åˆ° Three.js æ¸²æŸ“è¿´åœˆå¯è®€å–çš„ Ref
            useEffect(() => {
                pressureRef.current = pressure;
                valveStateRef.current = valveState;
            }, [pressure, valveState]);

            // --- Three.js å ´æ™¯åˆå§‹åŒ–èˆ‡æ¸²æŸ“ ---
            useEffect(() => {
                // ç¢ºä¿å®¹å™¨å­˜åœ¨æ‰ç¹¼çºŒ
                if (!mountRef.current) return;

                const initialWidth = mountRef.current.clientWidth || window.innerWidth;
                const initialHeight = mountRef.current.clientHeight || window.innerHeight;

                // 1. å ´æ™¯èˆ‡ç›¸æ©Ÿ
                const scene = new THREE.Scene();
                scene.background = new THREE.Color('#0f172a'); // æ›´æ·±çš„èƒŒæ™¯è‰²ä»¥çªé¡¯ UI èˆ‡æ¨¡å‹
                
                // å°‡ç›¸æ©Ÿç¨å¾®å¾€å·¦ç§»ä¸€é»ï¼Œè®“å³å´çš„æ§åˆ¶é¢æ¿ä¸æœƒé®æ“‹åˆ°æ¨¡å‹ä¸»é«”
                const camera = new THREE.PerspectiveCamera(40, initialWidth / initialHeight, 0.1, 1000);
                camera.position.set(-5, 5, 35); 

                const renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(initialWidth, initialHeight);
                renderer.shadowMap.enabled = true;
                mountRef.current.appendChild(renderer.domElement);

                const controls = new THREE.OrbitControls(camera, renderer.domElement);
                controls.target.set(0, 3, 0);
                controls.enableDamping = true;
                controls.maxPolarAngle = Math.PI / 2 + 0.2; // é™åˆ¶è¦–è§’ä¸è¦è·‘åˆ°åœ°åº•ä¸‹å¤ªå¤š

                // 2. ç‡ˆå…‰
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.5); 
                scene.add(ambientLight);
                
                const dirLight = new THREE.DirectionalLight(0xffffff, 1.0); 
                dirLight.position.set(10, 20, 15);
                dirLight.castShadow = true;
                scene.add(dirLight);

                const backLight = new THREE.DirectionalLight(0xffffff, 0.3);
                backLight.position.set(-10, 10, -15);
                scene.add(backLight);

                // --- 3. å»ºç«‹ 3D æ¨¡å‹ç‰©ä»¶ ---

                // å…±ç”¨æè³ª
                const metalMat = new THREE.MeshStandardMaterial({ color: 0x94a3b8, metalness: 0.6, roughness: 0.4 });
                const darkMetalMat = new THREE.MeshStandardMaterial({ color: 0x475569, metalness: 0.8, roughness: 0.3 });
                const brassMat = new THREE.MeshStandardMaterial({ color: 0xf59e0b, metalness: 0.8, roughness: 0.2 });
                // ç»ç’ƒé–¥é«”æè³ªï¼Œè®“å…§éƒ¨ä½œå‹•æ¸…æ™°å¯è¦‹
                const glassMat = new THREE.MeshPhysicalMaterial({
                    color: 0xbae6fd, transmission: 0.8, opacity: 1, metalness: 0.1, roughness: 0.1, transparent: true
                });

                // (A) å£“åŠ›å®¹å™¨ (Vessel)
                const vesselMat = new THREE.MeshStandardMaterial({ color: 0x94a3b8 });
                sceneObjectsRef.current.vesselMat = vesselMat; // å„²å­˜èµ·ä¾†ä»¥å‹•æ…‹è®Šè‰²
                const vesselGeo = new THREE.CylinderGeometry(5, 5, 8, 32);
                const vessel = new THREE.Mesh(vesselGeo, vesselMat);
                vessel.position.y = -5;
                scene.add(vessel);

                // æ³•è˜­ç›¤ (Flange)
                const flangeGeo = new THREE.CylinderGeometry(3.5, 3.5, 0.5, 32);
                const flange = new THREE.Mesh(flangeGeo, darkMetalMat);
                flange.position.y = -1;
                scene.add(flange);

                // (B) å™´å˜´ (Nozzle / Seat)
                const nozzleGeo = new THREE.CylinderGeometry(1.2, 1.2, 2, 32);
                const nozzle = new THREE.Mesh(nozzleGeo, darkMetalMat);
                nozzle.position.y = 0; // é ‚éƒ¨åœ¨ y = 1
                scene.add(nozzle);

                // (C) ç»ç’ƒé–¥é«” (Valve Body)
                const bodyGeo = new THREE.CylinderGeometry(3, 3, 4, 32);
                const body = new THREE.Mesh(bodyGeo, glassMat);
                body.position.y = 3;
                scene.add(body);

                // æ’æ”¾å‡ºå£ (Outlet Pipe)
                const outletGeo = new THREE.CylinderGeometry(1.2, 1.2, 4, 32);
                const outlet = new THREE.Mesh(outletGeo, metalMat);
                outlet.rotation.z = Math.PI / 2;
                outlet.position.set(4, 3, 0);
                scene.add(outlet);

                // (D) æ´»å‹•çµ„ä»¶ç¾¤çµ„ (Moving Parts: é–¥ç“£ã€é–¥æ¡¿ã€å½ˆç°§ä¸‹æ‰˜ç›¤)
                const movingParts = new THREE.Group();
                scene.add(movingParts);
                sceneObjectsRef.current.movingParts = movingParts;

                // é–¥ç“£ (Disc) - æ¥è§¸é»åœ¨ y = 1.2 (å‰›å¥½è²¼é½Š Nozzle é ‚éƒ¨)
                const discGeo = new THREE.CylinderGeometry(1.4, 1.4, 0.4, 32);
                const disc = new THREE.Mesh(discGeo, brassMat);
                disc.position.y = 1.2; 
                movingParts.add(disc);

                // é–¥æ¡¿ (Stem)
                const stemGeo = new THREE.CylinderGeometry(0.2, 0.2, 8, 16);
                const stem = new THREE.Mesh(stemGeo, metalMat);
                stem.position.y = 5.4;
                movingParts.add(stem);

                // å½ˆç°§ä¸‹æ‰˜ç›¤ (Bottom Spring Plate)
                const bottomPlateGeo = new THREE.CylinderGeometry(1.5, 1.5, 0.2, 32);
                const bottomPlate = new THREE.Mesh(bottomPlateGeo, darkMetalMat);
                bottomPlate.position.y = 6.5; // å½ˆç°§åº•éƒ¨èµ·å§‹é»
                movingParts.add(bottomPlate);

                // (E) å›ºå®šæ”¯æ¶çµæ§‹ (Yoke)
                // é–¥é«”ä¸Šè“‹
                const topCoverGeo = new THREE.CylinderGeometry(3.2, 3.2, 0.4, 32);
                const topCover = new THREE.Mesh(topCoverGeo, darkMetalMat);
                topCover.position.y = 5.2;
                scene.add(topCover);

                // é›™å´æ”¯æŸ±
                const pillarGeo = new THREE.CylinderGeometry(0.3, 0.3, 5, 16);
                const pillar1 = new THREE.Mesh(pillarGeo, metalMat);
                pillar1.position.set(2.2, 7.7, 0);
                scene.add(pillar1);
                const pillar2 = new THREE.Mesh(pillarGeo, metalMat);
                pillar2.position.set(-2.2, 7.7, 0);
                scene.add(pillar2);

                // é ‚éƒ¨æ©«æ¨‘èˆ‡å½ˆç°§ä¸Šæ‰˜ç›¤
                const topBeamGeo = new THREE.BoxGeometry(5.5, 0.6, 2);
                const topBeam = new THREE.Mesh(topBeamGeo, darkMetalMat);
                topBeam.position.y = 10.2;
                scene.add(topBeam);
                
                const topPlateGeo = new THREE.CylinderGeometry(1.5, 1.5, 0.2, 32);
                const topPlate = new THREE.Mesh(topPlateGeo, darkMetalMat);
                topPlate.position.y = 9.8; // å½ˆç°§é ‚éƒ¨çµ‚é»
                scene.add(topPlate);

                // é ‚éƒ¨èª¿ç¯€èºçµ² (Adjusting Screw)
                const screwGeo = new THREE.CylinderGeometry(0.4, 0.4, 1.5, 16);
                const screw = new THREE.Mesh(screwGeo, brassMat);
                screw.position.y = 11;
                scene.add(screw);

                // (F) å‹•æ…‹å½ˆç°§ (Spring)
                let springMesh = null;
                const updateSpringGeometry = (bottomY, topY) => {
                    if (springMesh) {
                        scene.remove(springMesh);
                        springMesh.geometry.dispose();
                        springMesh.material.dispose();
                    }
                    const points = [];
                    const coils = 5;
                    const segments = 100;
                    for (let i = 0; i <= segments; i++) {
                        const t = i / segments;
                        const angle = t * Math.PI * 2 * coils;
                        const x = Math.cos(angle) * 1.2;
                        const z = Math.sin(angle) * 1.2;
                        const y = bottomY + t * (topY - bottomY);
                        points.push(new THREE.Vector3(x, y, z));
                    }
                    const curve = new THREE.CatmullRomCurve3(points);
                    const tubeGeo = new THREE.TubeGeometry(curve, segments, 0.15, 8, false);
                    const tubeMat = new THREE.MeshStandardMaterial({ color: 0x1e293b, metalness: 0.3, roughness: 0.7 });
                    springMesh = new THREE.Mesh(tubeGeo, tubeMat);
                    scene.add(springMesh);
                };

                // (G) è’¸æ°£ç²’å­ç³»çµ± (Steam Particles)
                const particlesGroup = new THREE.Group();
                scene.add(particlesGroup);
                const particleData = [];

                // --- æ¸²æŸ“èˆ‡å‹•ç•«è¿´åœˆ ---
                let animationId;
                let currentDiscOffset = 0;

                const animate = () => {
                    animationId = requestAnimationFrame(animate);
                    controls.update();

                    const currentPressure = pressureRef.current;
                    const currentState = valveStateRef.current;

                    // 1. è™•ç†å®¹å™¨è®Šè‰² (éš¨å£“åŠ›è®Šç´…)
                    const ratio = currentPressure / MAX_PRESSURE;
                    const r = Math.min(1, 0.4 + ratio * 0.6);
                    const g = Math.max(0, 0.8 - ratio * 0.8);
                    const b = Math.max(0, 1.0 - ratio * 1.0);
                    vesselMat.color.setRGB(r, g, b);

                    // 2. è™•ç†é–¥ç“£(Disc)ä½ç§»å¹³æ»‘éæ¸¡
                    let targetOffset = 0;
                    if (currentState === 'OPEN') targetOffset = 1.5;
                    if (currentState === 'SIMMERING') targetOffset = 0.15;
                    
                    // å¹³æ»‘ç§»å‹• (Lerp)
                    currentDiscOffset += (targetOffset - currentDiscOffset) * 0.2;
                    movingParts.position.y = currentDiscOffset;

                    // 3. å³æ™‚é‡ç¹ªå½ˆç°§ (æ ¹æ“šæ‰˜ç›¤ä½ç½®)
                    const springBottomY = 6.6 + currentDiscOffset;
                    const springTopY = 9.7;
                    updateSpringGeometry(springBottomY, springTopY);

                    // 4. è™•ç†è’¸æ°£ç²’å­ç™¼å°„
                    if (currentState === 'OPEN' || currentState === 'SIMMERING') {
                        const isHeavy = currentState === 'OPEN';
                        // æ¯å¹€ç™¼å°„æ©Ÿç‡
                        if (Math.random() > (isHeavy ? 0.2 : 0.6)) {
                            const pGeo = new THREE.SphereGeometry(isHeavy ? 0.8 : 0.4, 8, 8);
                            const pMat = new THREE.MeshBasicMaterial({
                                color: 0xffffff, transparent: true, opacity: isHeavy ? 0.7 : 0.3
                            });
                            const p = new THREE.Mesh(pGeo, pMat);
                            
                            // å¾æ’æ”¾å£èµ·é»ç™¼å°„
                            p.position.set(5.5, 3 + (Math.random()-0.5)*0.5, (Math.random()-0.5)*0.5);
                            
                            const vx = (isHeavy ? 0.8 : 0.2) + Math.random() * 0.4;
                            const vy = (Math.random() - 0.2) * 0.2;
                            const vz = (Math.random() - 0.5) * 0.2;

                            particlesGroup.add(p);
                            particleData.push({
                                mesh: p, vx, vy, vz,
                                life: 0, maxLife: isHeavy ? 50 : 25
                            });
                        }
                    }

                    // 5. æ›´æ–°ç¾æœ‰ç²’å­ç‹€æ…‹
                    for (let i = particleData.length - 1; i >= 0; i--) {
                        const data = particleData[i];
                        data.life++;
                        data.mesh.position.x += data.vx;
                        data.mesh.position.y += data.vy;
                        data.mesh.position.z += data.vz;
                        
                        // æ¨¡æ“¬è’¸æ°£æ“´æ•£èˆ‡æ¶ˆæ•£
                        data.mesh.scale.multiplyScalar(1.04); 
                        data.mesh.material.opacity *= 0.92; 

                        if (data.life > data.maxLife) {
                            particlesGroup.remove(data.mesh);
                            data.mesh.geometry.dispose();
                            data.mesh.material.dispose();
                            particleData.splice(i, 1);
                        }
                    }

                    renderer.render(scene, camera);
                };

                animate();

                // è§£æ±ºåˆå§‹è¼‰å…¥æ™‚å…ƒç´ å°ºå¯¸å°šæœªå±•é–‹çš„å•é¡Œ
                const handleResize = () => {
                    if (!mountRef.current) return;
                    const w = mountRef.current.clientWidth;
                    const h = mountRef.current.clientHeight;
                    
                    // é¿å…åœ¨å…ƒç´ å°šæœªå±•é–‹å‰ä½¿ç”¨ç„¡æ•ˆå°ºå¯¸
                    if (w === 0 || h === 0) return;
                    
                    camera.aspect = w / h;
                    camera.updateProjectionMatrix();
                    renderer.setSize(w, h);
                };

                // ä½¿ç”¨ ResizeObserver ä¸»å‹•ç›£è½å®¹å™¨å°ºå¯¸è®ŠåŒ–
                const resizeObserver = new ResizeObserver(() => {
                    handleResize();
                });
                
                if (mountRef.current) {
                    resizeObserver.observe(mountRef.current);
                }

                // Cleanup
                return () => {
                    resizeObserver.disconnect();
                    cancelAnimationFrame(animationId);
                    if (mountRef.current && renderer.domElement) {
                        mountRef.current.removeChild(renderer.domElement);
                    }
                };
            }, []);

            return (
                <div className="relative w-full h-full rounded-2xl shadow-2xl overflow-hidden border border-slate-700 bg-slate-900 flex flex-col">
                    
                    {/* é ‚éƒ¨è³‡è¨Šåˆ— (çµ•å°å®šä½è¦†è“‹) */}
                    <div className="absolute top-0 left-0 right-0 z-20 bg-slate-900/80 backdrop-blur-md text-white py-3 px-6 text-lg font-bold flex justify-between items-center border-b border-slate-700/50">
                        <span>3D å…§éƒ¨ä½œå‹•é€è¦–åœ– (å¯æ»‘é¼ æ‹–æ›³æ—‹è½‰)</span>
                        <span className={`px-4 py-1.5 rounded-full text-sm font-bold shadow-lg ${
                            valveState === 'OPEN' ? 'bg-red-500 text-white' : 
                            valveState === 'SIMMERING' ? 'bg-yellow-400 text-black' : 'bg-emerald-500 text-white'
                        }`}>
                            {valveState === 'OPEN' ? 'å…¨é–‹æ’æ”¾ä¸­' : 
                             valveState === 'SIMMERING' ? 'åˆå™´å¾®å•Ÿ' : 'å®Œå…¨é—œé–‰'}
                        </span>
                    </div>

                    {/* 3D Canvas èƒŒæ™¯ */}
                    <div ref={mountRef} className="absolute inset-0 z-0 cursor-move"></div>

                    {/* æµ®å‹•æ§åˆ¶é¢æ¿ (èåˆæ–¼ç•«é¢ä¸Šæ–¹) */}
                    <div className="absolute top-20 right-6 z-10 w-[340px] bg-white/95 backdrop-blur-xl p-6 rounded-2xl shadow-2xl border border-white/20">
                        <h2 className="text-xl font-bold text-slate-800 mb-5 border-b border-slate-200 pb-2 flex items-center gap-2">
                            âš™ï¸ ç³»çµ±å£“åŠ›æ§åˆ¶
                        </h2>
                        
                        <div className="mb-6 relative">
                            <div className="flex justify-between items-end mb-2">
                                <label className="text-slate-600 font-semibold">å…§éƒ¨å£“åŠ› (PSI)</label>
                                <div className={`text-3xl font-black font-mono transition-colors ${
                                    pressure >= SET_PRESSURE ? 'text-red-600' : 
                                    pressure >= SIMMER_PRESSURE ? 'text-orange-500' : 'text-blue-600'
                                }`}>
                                    {pressure.toFixed(1)}
                                </div>
                            </div>
                            
                            <input 
                                type="range" 
                                min="0" 
                                max={MAX_PRESSURE} 
                                step="0.5" 
                                value={pressure}
                                onChange={(e) => setPressure(parseFloat(e.target.value))}
                                className="w-full h-3 bg-slate-200 rounded-lg appearance-none cursor-pointer"
                            />
                            
                            {/* åˆ»åº¦æ¨™ç±¤ */}
                            <div className="relative w-full h-8 mt-1 text-[11px] text-slate-500 font-mono">
                                <span className="absolute left-0 mt-2">0</span>
                                
                                <div className="absolute flex flex-col items-center" 
                                     style={{ left: `${(RESEAT_PRESSURE / MAX_PRESSURE) * 100}%`, transform: 'translateX(-50%)' }}>
                                    <div className="w-0.5 h-1.5 bg-slate-400 mb-0.5 rounded"></div>
                                    <span>{RESEAT_PRESSURE}</span>
                                    <span className="text-[9px] text-slate-400 -mt-1">(å›åº§)</span>
                                </div>
                                
                                <div className="absolute flex flex-col items-center" 
                                     style={{ left: `${(SET_PRESSURE / MAX_PRESSURE) * 100}%`, transform: 'translateX(-50%)' }}>
                                    <div className="w-0.5 h-1.5 bg-red-400 mb-0.5 rounded"></div>
                                    <span className="text-red-500 font-bold">{SET_PRESSURE}</span>
                                    <span className="text-[9px] text-red-400 -mt-1">(èµ·è·³)</span>
                                </div>
                                
                                <span className="absolute right-0 mt-2">{MAX_PRESSURE}</span>
                            </div>
                        </div>

                        {/* ç‹€æ…‹èªªæ˜é¢æ¿ */}
                        <div className="bg-slate-50 rounded-xl p-4 border border-slate-200 shadow-inner">
                            <h3 className="font-bold text-slate-700 mb-2 text-sm">é–¥é–€ç‹€æ…‹</h3>
                            
                            {valveState === 'CLOSED' && (
                                <div className="flex items-start gap-2 text-emerald-700 bg-emerald-50/50 p-2.5 rounded-lg border border-emerald-100">
                                    <div className="mt-0.5 text-xl">ğŸŸ¢</div>
                                    <div>
                                        <div className="font-bold text-md">é—œé–‰ (Closed)</div>
                                        <p className="text-xs mt-1 leading-tight text-emerald-600/80">å£“åŠ›æ­£å¸¸ã€‚å½ˆç°§ä¸‹å£“åŠ›å¤§æ–¼å…§éƒ¨å£“åŠ›ï¼Œé–¥ç“£ç·Šå£“åº•åº§ã€‚</p>
                                    </div>
                                </div>
                            )}

                            {valveState === 'SIMMERING' && (
                                <div className="flex items-start gap-2 text-orange-700 bg-orange-50/50 p-2.5 rounded-lg border border-orange-100">
                                    <div className="mt-0.5 text-xl">ğŸŸ¡</div>
                                    <div>
                                        <div className="font-bold text-md">åˆå™´ / å¾®å•Ÿ</div>
                                        <p className="text-xs mt-1 leading-tight text-orange-600/80">æ¥è¿‘è¨­å®šå£“åŠ›ã€‚é–¥ç“£å¾®å¹…æŠ¬èµ·ï¼Œå°é‡è’¸æ°£æ´©æ¼ã€‚</p>
                                    </div>
                                </div>
                            )}

                            {valveState === 'OPEN' && (
                                <div className="flex items-start gap-2 text-red-700 bg-red-50/50 p-2.5 rounded-lg border border-red-100">
                                    <div className="mt-0.5 text-xl animate-pulse">ğŸ”´</div>
                                    <div>
                                        <div className="font-bold text-md">æ’æ”¾ / èµ·è·³</div>
                                        <p className="text-xs mt-1 leading-tight text-red-600/80">å£“åŠ›è¶…æ¨™å…¨é–‹ï¼é™è‡³ {RESEAT_PRESSURE} PSI ä»¥ä¸‹æ‰æœƒå›åº§ã€‚</p>
                                    </div>
                                </div>
                            )}
                        </div>
                    </div>

                    {/* å·¦ä¸‹è§’æç¤ºæ¡† */}
                    <div className="absolute bottom-6 left-6 z-10 bg-slate-900/60 backdrop-blur-sm px-4 py-2 rounded-lg text-xs text-slate-300 font-bold pointer-events-none border border-slate-600/50 shadow-lg">
                        ğŸ’¡ æç¤ºï¼šå·¦éµæ‹–æ›³æ—‹è½‰ / æ»¾è¼ªç¸®æ”¾
                    </div>

                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>

<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>3D 起重機吊掛練習器 - 競速版</title>
    
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="theme-color" content="#0f172a">

    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #0f172a; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; touch-action: none; }
        #canvas-container { width: 100%; height: 100vh; display: block; position: absolute; top: 0; left: 0; z-index: 1; }
        .noselect { user-select: none; -webkit-user-select: none; -webkit-touch-callout: none; }

        /* === UI 介面層 === */
        
        /* 1. 左上角羅盤 */
        #compass-container {
            position: absolute; top: 20px; left: 20px; z-index: 10;
            display: flex; gap: 20px; align-items: flex-start;
            pointer-events: none;
        }
        #compass {
            width: 90px; height: 90px;
            background: rgba(20, 25, 40, 0.4); /* 稍微調淡 */
            border-radius: 50%;
            border: 2px solid rgba(255, 255, 255, 0.15);
            position: relative;
            backdrop-filter: blur(2px);
        }
        .cp-label { position: absolute; font-weight: 900; font-size: 14px; text-shadow: 0 1px 3px black; }
        .cp-n { top: 5px; left: 50%; transform: translateX(-50%); color: #ef4444; }
        .cp-s { bottom: 5px; left: 50%; transform: translateX(-50%); color: #fff; }
        .cp-e { right: 8px; top: 50%; transform: translateY(-50%); color: #fff; }
        .cp-w { left: 8px; top: 50%; transform: translateY(-50%); color: #fff; }
        .cp-cross-v { position: absolute; top: 15%; bottom: 15%; left: 50%; width: 1px; background: rgba(255,255,255,0.2); transform: translateX(-50%); }
        .cp-cross-h { position: absolute; left: 15%; right: 15%; top: 50%; height: 1px; background: rgba(255,255,255,0.2); transform: translateY(-50%); }
        .cp-center { position: absolute; top: 50%; left: 50%; width: 6px; height: 6px; background: white; border-radius: 50%; transform: translate(-50%, -50%); }

        /* 2. 橘色遙控器 (半透明化) */
        #rc-container {
            position: absolute; bottom: 20px; right: 20px; z-index: 10;
            transform-origin: bottom right;
            transform: scale(0.9); 
        }
        .rc-body {
            /* 改為 RGBA 半透明橘色 */
            background-color: rgba(234, 88, 12, 0.65); 
            width: 130px;
            border-radius: 16px;
            padding: 15px 10px;
            box-shadow: 
                0 10px 20px rgba(0,0,0,0.3),
                inset 2px 2px 5px rgba(255,255,255,0.2),
                inset -2px -2px 5px rgba(0,0,0,0.1);
            display: flex;
            flex-direction: column;
            gap: 12px;
            border: 1px solid rgba(194, 65, 12, 0.5);
            /* 加入毛玻璃效果 */
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
        }
        .rc-top-slot {
            width: 60%; height: 6px; background: rgba(0,0,0,0.2); 
            margin: 0 auto 5px auto; border-radius: 3px;
        }
        .rc-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px 10px;
            padding: 0 5px;
        }
        .btn-slot-empty {
            height: 45px;
            border-radius: 8px;
            background: rgba(0,0,0,0.1);
            border: 1px solid rgba(0,0,0,0.15);
            box-shadow: inset 1px 1px 3px rgba(0,0,0,0.1);
        }
        .btn-black {
            height: 45px;
            /* 按鈕稍微保留實體感，但也帶一點點透明 */
            background: radial-gradient(circle at 35% 30%, rgba(63, 63, 70, 0.9), rgba(24, 24, 27, 0.95));
            border-radius: 10px;
            border: 1px solid rgba(0,0,0,0.5);
            color: white;
            font-weight: bold;
            font-size: 16px;
            display: flex; align-items: center; justify-content: center;
            box-shadow: 0 4px 5px rgba(0,0,0,0.3), inset 0 1px 1px rgba(255,255,255,0.2);
            cursor: pointer;
            -webkit-tap-highlight-color: transparent;
            transition: transform 0.05s, box-shadow 0.05s;
            position: relative;
        }
        .btn-black:active, .btn-black.active {
            transform: translateY(2px);
            box-shadow: 0 1px 1px rgba(0,0,0,0.3), inset 0 2px 5px rgba(0,0,0,0.6);
            color: #fbbf24;
        }
        .rc-label {
            font-size: 9px; font-weight: 800; color: #1f2937; text-align: center; margin-bottom: 2px; text-transform: uppercase;
            text-shadow: 0 0 2px rgba(255,255,255,0.3); /* 增加文字可讀性 */
        }
        .rc-footer {
            margin-top: 5px; text-align: center; font-size: 8px; font-weight: 800; color: rgba(0,0,0,0.4);
        }

        /* 碰撞閃爍紅框 */
        #collision-flash {
            position: fixed; top: 0; left: 0; right: 0; bottom: 0;
            border: 0px solid #ef4444; pointer-events: none; z-index: 5;
            transition: border-width 0.1s;
        }

        /* 重置按鈕 */
        #reset-btn {
            position: absolute; bottom: 20px; left: 20px; z-index: 20;
            background: rgba(55, 65, 81, 0.6); 
            border: 1px solid rgba(75, 85, 99, 0.5);
            backdrop-filter: blur(4px);
            color: #e5e7eb; padding: 6px 12px; border-radius: 6px; font-size: 12px;
            cursor: pointer;
            transition: background 0.2s;
        }
        #reset-btn:hover { background: rgba(55, 65, 81, 0.9); }
    </style>
</head>
<body class="noselect">

    <div id="canvas-container"></div>
    <div id="collision-flash"></div>

    <!-- UI 容器 -->
    <div id="compass-container">
        <!-- 羅盤 -->
        <div id="compass">
            <div class="cp-cross-v"></div>
            <div class="cp-cross-h"></div>
            <div class="cp-label cp-n">北</div>
            <div class="cp-label cp-s">南</div>
            <div class="cp-label cp-e">東</div>
            <div class="cp-label cp-w">西</div>
            <div class="cp-center"></div>
        </div>
        <!-- 速度表已移除 -->
    </div>

    <!-- 遙控器 -->
    <div id="rc-container">
        <div class="rc-body">
            <div class="rc-top-slot"></div>
            
            <div class="rc-grid">
                <div><div class="btn-slot-empty"></div></div>
                <div>
                    <div class="rc-label">UP</div>
                    <div id="btn-up" class="btn-black" data-action="up">上</div>
                </div>
                <div><div class="btn-slot-empty"></div></div>
                <div>
                    <div class="rc-label">DOWN</div>
                    <div id="btn-down" class="btn-black" data-action="down">下</div>
                </div>
            </div>

            <div style="height:1px; background:rgba(0,0,0,0.1); margin: 5px 0;"></div>

            <div class="rc-grid">
                <div>
                    <div class="rc-label">SOUTH</div>
                    <div id="btn-south" class="btn-black" data-action="south">南</div>
                </div>
                <div>
                    <div class="rc-label">EAST</div>
                    <div id="btn-east" class="btn-black" data-action="east">東</div>
                </div>
                <div>
                    <div class="rc-label">NORTH</div>
                    <div id="btn-north" class="btn-black" data-action="north">北</div>
                </div>
                <div>
                    <div class="rc-label">WEST</div>
                    <div id="btn-west" class="btn-black" data-action="west">西</div>
                </div>
            </div>

            <div class="rc-footer">CRANE CONTROLLER</div>
        </div>
    </div>

    <button id="reset-btn" onclick="resetGame()">重置位置</button>

    <script>
        // --- 1. 速度設定 (加速 6 倍) ---
        // Bridge: ~2.1 m/s, Trolley: ~1.45 m/s
        const SPEED_MULTIPLIER = 6.0;
        const REAL_SPEEDS = {
            bridge: (21.0 / 60.0) * SPEED_MULTIPLIER,
            trolley: (14.5 / 60.0) * SPEED_MULTIPLIER,
            hoist: (4.8 / 60.0) * SPEED_MULTIPLIER
        };

        const state = {
            move: { north: false, south: false, east: false, west: false, up: false, down: false },
            velocity: { bridge: 0, trolley: 0, hoist: 0 },
            // 加速參數調整：確保約 1 秒內達到最大值
            // a = v_max / 1s
            physics: {
                accel: { 
                    bridge: REAL_SPEEDS.bridge,   // ~2.1 m/s^2
                    trolley: REAL_SPEEDS.trolley, // ~1.45 m/s^2
                    hoist: REAL_SPEEDS.hoist * 2  // 吊鉤稍微反應快一點
                }, 
                decel: { bridge: 0.8, trolley: 0.8, hoist: 1.0 }
            },
            limits: { x: 50, z: 40, minL: 1, maxL: 24 },
            bridgeY: 25, 
            bridgeZ: 0,
            trolleyX: -26,
            cableLength: 0,
            collisions: 0
        };

        const GRAVITY_FORCE = 35.0; 
        const DAMPING = 0.999; 

        // --- 2. 系統變數 ---
        const clock = new THREE.Clock();
        const gravity = new THREE.Vector3(0, -GRAVITY_FORCE, 0);
        let payloadPos = new THREE.Vector3();
        let payloadPrevPos = new THREE.Vector3();
        const obstacles = [];
        
        const collisionFlash = document.getElementById('collision-flash');

        // --- 3. Three.js 初始化 ---
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color('#94a3b8'); 
        scene.fog = new THREE.Fog('#94a3b8', 20, 150);

        const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 1.7, 50);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        container.appendChild(renderer.domElement);

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // 燈光
        scene.add(new THREE.AmbientLight(0xffffff, 0.6));
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(40, 80, 40);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.set(2048, 2048);
        dirLight.shadow.camera.left = -60; dirLight.shadow.camera.right = 60;
        dirLight.shadow.camera.top = 60; dirLight.shadow.camera.bottom = -60;
        scene.add(dirLight);

        // 地板
        const floor = new THREE.Mesh(
            new THREE.PlaneGeometry(200, 200),
            new THREE.MeshStandardMaterial({ color: '#e2e8f0', roughness: 0.8 })
        );
        floor.rotation.x = -Math.PI / 2;
        floor.receiveShadow = true;
        scene.add(floor);
        scene.add(new THREE.GridHelper(120, 12, 0x94a3b8, 0xcbd5e1));

        // **輔助投影 (Drop Shadow Marker)** - 保留此陰影作為對準依據
        const shadowMarkerGeo = new THREE.RingGeometry(0.1, 0.8, 32);
        const shadowMarkerMat = new THREE.MeshBasicMaterial({ 
            color: 0x000000, 
            transparent: true, 
            opacity: 0.3,
            side: THREE.DoubleSide
        });
        const shadowMarker = new THREE.Mesh(shadowMarkerGeo, shadowMarkerMat);
        shadowMarker.rotation.x = -Math.PI / 2;
        shadowMarker.position.y = 0.02; 
        scene.add(shadowMarker);

        // --- 4. 場景物件 ---
        const craneGroup = new THREE.Group();
        scene.add(craneGroup);

        const matMetalDark = new THREE.MeshStandardMaterial({ color: '#334155' });
        const matMetalLight = new THREE.MeshStandardMaterial({ color: '#64748b' });
        
        const railL = new THREE.Mesh(new THREE.BoxGeometry(2, 2, 100), matMetalDark);
        railL.position.set(-50, state.bridgeY + 1, 0); scene.add(railL);
        const railR = new THREE.Mesh(new THREE.BoxGeometry(2, 2, 100), matMetalDark);
        railR.position.set(50, state.bridgeY + 1, 0); scene.add(railR);
        
        [[-50, -45], [-50, 45], [50, -45], [50, 45]].forEach(p => {
            const post = new THREE.Mesh(new THREE.BoxGeometry(2, state.bridgeY + 1, 2), matMetalLight);
            post.position.set(p[0], (state.bridgeY + 1)/2, p[1]); scene.add(post);
        });

        const bridgeMesh = new THREE.Mesh(
            new THREE.BoxGeometry(102, 2, 3), 
            new THREE.MeshStandardMaterial({ color: '#fbbf24' }) 
        );
        scene.add(bridgeMesh);

        const trolleyMesh = new THREE.Mesh(
            new THREE.BoxGeometry(4, 2, 4),
            new THREE.MeshStandardMaterial({ color: '#1d4ed8' }) 
        );
        scene.add(trolleyMesh);

        const cableGeo = new THREE.CylinderGeometry(0.04, 0.04, 1, 8);
        cableGeo.translate(0, 0.5, 0); 
        const cableMesh = new THREE.Mesh(cableGeo, new THREE.MeshStandardMaterial({ color: 0x222222 }));
        scene.add(cableMesh);

        const payloadGroup = new THREE.Group();
        const boxMesh = new THREE.Mesh(
            new THREE.CylinderGeometry(0.8, 0.8, 1.2, 32),
            new THREE.MeshStandardMaterial({ color: '#2563eb' })
        );
        boxMesh.castShadow = false; // 關鍵修正：關閉貨物本身的陰影，只保留輔助投影
        payloadGroup.add(boxMesh);
        
        const hook = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.1, 0.6), matMetalDark);
        hook.position.y = 0.9;
        payloadGroup.add(hook);
        scene.add(payloadGroup);

        function createCourse() {
            const pathPoints = [
                {x:-26,z:0}, {x:-16,z:-16}, {x:16,z:-16}, {x:26,z:0},
                {x:16,z:16}, {x:0,z:6}, {x:-16,z:16}, {x:-26,z:0}
            ].map(p => new THREE.Vector3(p.x, 0.1, p.z));
            const pathLine = new THREE.Line(
                new THREE.BufferGeometry().setFromPoints(pathPoints),
                new THREE.LineBasicMaterial({ color: '#0000ff', linewidth: 3 })
            );
            scene.add(pathLine);

            const poleGeo = new THREE.CylinderGeometry(0.2, 0.2, 6, 16);
            const poleMat = new THREE.MeshStandardMaterial({ color: '#f97316' });
            [
                {x:-18,z:-18}, {x:-14,z:-14}, {x:18,z:-18}, {x:14,z:-14},
                {x:28,z:0}, {x:24,z:0}, {x:18,z:18}, {x:14,z:14},
                {x:2,z:8}, {x:-2,z:8}, {x:-18,z:18}, {x:-14,z:14},
                {x:-24,z:2}, {x:-24,z:-2}
            ].forEach(p => {
                const pole = new THREE.Mesh(poleGeo, poleMat);
                pole.position.set(p.x, 3, p.z);
                pole.castShadow = true;
                scene.add(pole);
                obstacles.push(pole);
            });

            createHurdle(0, -16, 2.0, 6, false); 
            createHurdle(-21, 8, 2.0, 6, false); 
            createWall(0, 6);
        }

        function createHurdle(x, z, h, w, vert) {
            const bar = new THREE.Mesh(
                new THREE.BoxGeometry(vert?0.2:w, 0.2, vert?w:0.2),
                new THREE.MeshStandardMaterial({ color: '#ef4444' })
            );
            bar.position.set(x, h, z);
            bar.castShadow = true;
            scene.add(bar);
            obstacles.push(bar);
            const leg = new THREE.Mesh(new THREE.CylinderGeometry(0.1,0.1,h), new THREE.MeshStandardMaterial({color:'#64748b'}));
            const l1=leg.clone(); l1.position.set(vert?x:x-w/2, h/2, vert?z-w/2:z); scene.add(l1);
            const l2=leg.clone(); l2.position.set(vert?x:x+w/2, h/2, vert?z+w/2:z); scene.add(l2);
            obstacles.push(l1); obstacles.push(l2);
        }

        function createWall(x, z) {
            const p = new THREE.Mesh(new THREE.CylinderGeometry(0.15, 0.15, 6, 16), new THREE.MeshStandardMaterial({color:'#ef4444'}));
            const p1=p.clone(); p1.position.set(x-1.5, 3, z); scene.add(p1); obstacles.push(p1);
            const p2=p.clone(); p2.position.set(x+1.5, 3, z); scene.add(p2); obstacles.push(p2);
        }

        createCourse();

        // --- 5. 核心邏輯 ---
        function updateVelocity(curr, target, accel, decel, dt) {
            if (target !== 0) {
                if (curr < target) return Math.min(target, curr + accel * dt);
                else return Math.max(target, curr - accel * dt);
            } else {
                if (curr > 0) return Math.max(0, curr - decel * dt);
                else if (curr < 0) return Math.min(0, curr + decel * dt);
                return 0;
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            const dt = Math.min(clock.getDelta(), 0.05);

            // 1. 速度更新
            let tgB=0, tgT=0, tgH=0;
            if (state.move.north) tgB = -REAL_SPEEDS.bridge;
            if (state.move.south) tgB = REAL_SPEEDS.bridge;
            if (state.move.west) tgT = -REAL_SPEEDS.trolley;
            if (state.move.east) tgT = REAL_SPEEDS.trolley;
            if (state.move.up) tgH = -REAL_SPEEDS.hoist;
            if (state.move.down) tgH = REAL_SPEEDS.hoist;

            state.velocity.bridge = updateVelocity(state.velocity.bridge, tgB, state.physics.accel.bridge, state.physics.decel.bridge, dt);
            state.velocity.trolley = updateVelocity(state.velocity.trolley, tgT, state.physics.accel.trolley, state.physics.decel.trolley, dt);
            state.velocity.hoist = updateVelocity(state.velocity.hoist, tgH, state.physics.accel.hoist, state.physics.decel.hoist, dt);

            // 2. 位置積分
            state.bridgeZ += state.velocity.bridge * dt;
            state.trolleyX += state.velocity.trolley * dt;
            state.cableLength += state.velocity.hoist * dt;

            // 邊界檢查
            if (state.bridgeZ < -state.limits.z || state.bridgeZ > state.limits.z) {
                state.bridgeZ = THREE.MathUtils.clamp(state.bridgeZ, -state.limits.z, state.limits.z);
                state.velocity.bridge = 0;
            }
            if (state.trolleyX < -state.limits.x || state.trolleyX > state.limits.x) {
                state.trolleyX = THREE.MathUtils.clamp(state.trolleyX, -state.limits.x, state.limits.x);
                state.velocity.trolley = 0;
            }
            state.cableLength = THREE.MathUtils.clamp(state.cableLength, state.limits.minL, state.limits.maxL);

            // 3. 更新機械視覺
            bridgeMesh.position.z = state.bridgeZ;
            bridgeMesh.position.y = state.bridgeY;
            trolleyMesh.position.set(state.trolleyX, state.bridgeY, state.bridgeZ);

            // 4. 物理運算
            const pivot = new THREE.Vector3(state.trolleyX, state.bridgeY, state.bridgeZ);
            let temp = payloadPos.clone();
            let vel = payloadPos.clone().sub(payloadPrevPos).multiplyScalar(DAMPING);
            let next = payloadPos.clone().add(vel).add(gravity.clone().multiplyScalar(dt * dt));

            let diff = next.clone().sub(pivot);
            let dist = diff.length();
            if (dist > 0.0001) {
                diff.multiplyScalar(state.cableLength / dist);
                next = pivot.clone().add(diff);
            }

            if (next.y < 0.6) {
                next.y = 0.6;
                // 地面摩擦
                payloadPrevPos.x = THREE.MathUtils.lerp(payloadPrevPos.x, next.x, 0.2); 
                payloadPrevPos.z = THREE.MathUtils.lerp(payloadPrevPos.z, next.z, 0.2);
            }

            payloadPrevPos.copy(temp);
            payloadPos.copy(next);
            payloadGroup.position.copy(payloadPos);

            // 5. 更新鋼索與鏡頭
            const cableVec = new THREE.Vector3().subVectors(new THREE.Vector3(payloadPos.x, payloadPos.y+0.9, payloadPos.z), pivot);
            cableMesh.position.copy(pivot);
            cableMesh.scale.set(1, cableVec.length(), 1);
            if (cableVec.length() > 0.001) {
                cableMesh.quaternion.setFromUnitVectors(new THREE.Vector3(0,1,0), cableVec.normalize());
            }

            // 更新陰影標記位置
            shadowMarker.position.x = payloadPos.x;
            shadowMarker.position.z = payloadPos.z;

            // --- 視角控制 (模擬人員站立視角) ---
            const camOffset = new THREE.Vector3(0, 1.7, 25); 
            const targetCamPos = payloadPos.clone().add(camOffset);
            
            if(targetCamPos.y < 1.7) targetCamPos.y = 1.7;

            camera.position.lerp(targetCamPos, 0.1);
            camera.lookAt(payloadPos.x, payloadPos.y + 1, payloadPos.z);

            // 簡單碰撞
            const pBox = new THREE.Box3().setFromObject(boxMesh);
            pBox.expandByScalar(-0.1);
            let hit = false;
            obstacles.forEach(o => {
                if (pBox.intersectsBox(new THREE.Box3().setFromObject(o))) {
                    hit = true;
                    if(!o.userData.hit) { o.userData.hit=true; o.material.emissive.setHex(0xff0000); }
                }
            });
            collisionFlash.style.borderWidth = hit ? '5px' : '0px';

            renderer.render(scene, camera);
        }

        function resetGame() {
            state.bridgeZ = 0; state.trolleyX = -26; state.cableLength = state.bridgeY - 0.6;
            state.velocity = { bridge:0, trolley:0, hoist:0 };
            payloadPos.set(-26, 0.6, 0); payloadPrevPos.copy(payloadPos);
            obstacles.forEach(o => { o.userData.hit=false; o.material.emissive.setHex(0x000000); });
        }

        // 綁定操作
        function setMove(act, down) { state.move[act] = down; const el=document.getElementById('btn-'+act); if(el) down?el.classList.add('active'):el.classList.remove('active'); }
        ['north','south','east','west','up','down'].forEach(k => {
            const btn = document.getElementById('btn-'+k);
            if(!btn) return;
            const start = (e) => { e.preventDefault(); setMove(k, true); };
            const end = (e) => { e.preventDefault(); setMove(k, false); };
            btn.addEventListener('mousedown', start); btn.addEventListener('touchstart', start, {passive:false});
            btn.addEventListener('mouseup', end); btn.addEventListener('touchend', end);
            btn.addEventListener('mouseleave', end); btn.addEventListener('touchcancel', end);
        });

        // 啟動
        resetGame();
        animate();

    </script>
</body>
</html>
